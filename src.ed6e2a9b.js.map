{"version":3,"sources":["random.ts","util.ts","episode.ts","display.ts","game.ts","index.ts"],"names":[],"mappings":"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","file":"src.ed6e2a9b.js","sourceRoot":"src","sourcesContent":["export class Random {\n\n\tconstructor(seed?: number) {\n    if (!seed) {\n      seed = crypto.getRandomValues(new Int32Array(1))[0] || 1;\n    }\n    this.state = seed;\n\t}\n\n\tnext() {\n\t\treturn this.state = xorshift32(this.state);\n\t}\n\n\tnextInt(min: number, max: number): number {\n\t\treturn Math.floor(map(this.next(), min, max + 1));\n\t}\n\n\tnextItem<Item>(array: Item[]): Item {\n\t\treturn array[this.nextInt(0, array.length - 1)];\n\t}\n\n\tstate: number;\n\n}\n\nlet i32Min = -0x80000000;\nlet i32Max = 0x7FFFFFFF;\n\nfunction map(x: number, min: number, max: number) {\n\treturn (x - i32Min) / (i32Max - i32Min) * (max - min) + min;\n}\n\n// TODO Consider splitmix64 or others sometime.\nfunction xorshift32(x: number) {\n\t// See:\n\t// http://www.jstatsoft.org/v08/i14/paper\n\t// https://en.wikipedia.org/wiki/Xorshift\n  x ^= x << 13;\n  x ^= x >> 17;\n  x ^= x << 5;\n  return x;\n}\n","export async function fetchObjectUri(uri: string) {\n  return URL.createObjectURL(await (await fetch(uri)).blob());\n}\n","import {Random} from './random';\nimport {FullSite, MinPlace, MinSite} from './place';\nimport {fetchObjectUri} from './util';\n\nexport type int = number;\nexport type Clue = string;\n\nexport interface ClueSite {\n  clue: Clue;\n  site: MinSite;\n}\n\nexport interface Episode {\n  // TODO Perpetrator\n  rounds: Round[];\n  seed: string;\n}\n\nexport interface EpisodeOptions {\n  cluesPerPlace?: int;\n  roundsPerEpisode?: int;\n  seed?: int;\n}\n\nexport interface Round {\n  place: MinPlace;\n  sites: ClueSite[];\n}\n\nexport async function generateEpisode(\n  places: MinPlace[], options: EpisodeOptions = {},\n) {\n  let episode = new EpisodeGenerator(places, options).generate();\n  await Promise.all(episode.rounds.map(async round => {\n    let {place} = round;\n    // Update place sites, which are the same sites as for the round.\n    // TODO If we reach a point of more sites than use with shuffling, load the\n    // TODO round clue sites rather than all the place sites.\n    let imageRequests = Promise.all(place.sites.map(async site => {\n      // TODO Remember to URL.revokeObjectURL() after each round?\n      site.image = await fetchObjectUri(`places/${place.id}/${site.image}`);\n    }));\n    let text =\n      await (await fetch(`places/${place.id}/${place.id}.html`)).text();\n    let data = new DOMParser().parseFromString(text, \"text/html\");\n    [...data.querySelectorAll('#images h2')].forEach((heading, siteIndex) => {\n      let divs = heading.children;\n      (place.sites[siteIndex] as FullSite).name = divs[0].textContent!;\n      // TODO Extract by game language. Or have files extracted for each lang?\n      (place.sites[siteIndex] as FullSite).nameUi = divs[1].textContent!;\n    })\n    await imageRequests;\n  }));\n  return episode;\n}\n\nclass EpisodeGenerator {\n\n  constructor(places: MinPlace[], options: EpisodeOptions = {}) {\n    let {seed} = options;\n    let random = new Random(seed);\n    Object.assign(\n      this,\n      // Defaults.\n      {\n        cluesPerPlace: 5,\n        roundsPerEpisode: 5 + 1,\n      },\n      // Options.\n      options,\n      // Explicits and overrides.\n      {\n        places,\n        random,\n        seed: random.state,\n      },\n    );\n  }\n\n  generate(): Episode {\n    // TODO Perp.\n    // The order has to be constant here.\n    let rounds =\n      [...Array(this.roundsPerEpisode).keys()].map(() => this.nextRound());\n    // Prep buffer for episode id.\n    let data = new DataView(new ArrayBuffer(4));\n    // Set with little endianness, since that's most common these days.\n    // What matters is that we have it consistent and defined.\n    data.setInt32(0, this.seed);\n    // Convert to base64.\n    // This doesn't get us far on just a 32 bit id, but we'll have git commit\n    // ids and possibly more random seed size later.\n    let seed = btoa(String.fromCharCode(...new Uint8Array(data.buffer)));\n    console.log(seed);\n    // Done.\n    return {rounds, seed};\n  }\n\n  nextRound(): Round {\n    // Important! The order of generation can't be changed, or else it breaks\n    // deterministic generation!\n    let {cluesPerPlace, nextPlace, places, random, roundsPerEpisode} = this;\n    // Current place and next.\n    let place = nextPlace || random.nextItem(places);\n    nextPlace = this.roundIndex < roundsPerEpisode ?\n      random.nextItem(places) :\n      undefined;\n    // Sites.\n    // TODO Always include skyline with clue, or just without clue?\n    let sites = [...Array(cluesPerPlace).keys()].map(() => {\n      // TODO This samples with replacement. Probably just shuffle instead.\n      let site = random.nextItem(place.sites);\n      let clue = '';\n      // Generate numbers now even if not used yet, for consistent production.\n      // TODO Remove this once really getting clues.\n      // TODO Do we get any \"clues\" at the last place?\n      if (nextPlace) {\n        random.nextInt(0, nextPlace!.sites.length);\n      }\n      return {clue, site} as ClueSite;\n    });\n    // Update and done.\n    this.nextPlace = nextPlace;\n    this.roundIndex += 1;\n    return {place, sites};\n  }\n\n  cluesPerPlace!: int;\n\n  nextPlace?: MinPlace = undefined;\n\n  places!: MinPlace[];\n\n  roundsPerEpisode!: int;\n\n  random!: Random;\n\n  roundIndex = 0;\n\n  seed!: int;\n\n}\n","import {Episode} from './episode';\nimport {FullSite, MinPlace} from './place';\n\nexport function renderArrows(siteIndex: number) {\n  let controls = document.querySelector('.control') as HTMLElement;\n  let goButtons = [...controls.querySelectorAll('.arrows .go')];\n  goButtons.forEach((element, index) => {\n    let button = element as HTMLElement;\n    if (siteIndex == index) {\n      button.classList.add('active');\n    } else {\n      button.classList.remove('active');\n    }\n  })\n}\n\nexport function renderRound(roundIndex: number, episode: Episode) {\n  let box = document.querySelector('.round') as HTMLElement;\n  let roundNumber = roundIndex + 1;\n  let {length} = episode.rounds;\n  box.textContent = roundNumber < length ?\n    `Round ${roundNumber}/${length - 1}` :\n    `Finale`;\n}\n\nexport async function renderSite(site: FullSite) {\n  // Image.\n  let img = document.querySelector('.photo img') as HTMLImageElement;\n  await setImgSrc(img, site.image);\n  // Controls.\n  (document.querySelector('.control') as HTMLElement).style.display = 'flex';\n  // Heading.\n  let headingKids = document.querySelector('h1')!.children;\n  headingKids[0].textContent = site.name;\n  headingKids[1].textContent = site.name == site.nameUi ? '' : site.nameUi;\n  // Text.\n  document.querySelector('.clue')!.textContent = 'Clue for the next place.';\n}\n\nfunction setImgSrc(img: HTMLImageElement, src: string): Promise<void> {\n  img.src = src;\n  return new Promise((resolve, reject) => {\n    if (img.complete) {\n      resolve();\n    }\n    img.addEventListener('error', onError);\n    img.addEventListener('load', onLoad);\n    // Functions.\n    function detach() {\n      img.removeEventListener('error', onError);\n      img.removeEventListener('load', onLoad);\n    }\n    function onError(event: ErrorEvent) {\n      detach();\n      reject(new Error(event.message));\n    }\n    function onLoad() {\n      detach();\n      resolve();\n    }\n  });\n}\n","import {renderArrows, renderRound, renderSite} from './display';\nimport {Episode} from './episode';\nimport {FullSite} from './place';\n\nexport class Game {\n\n  constructor() {\n    this.wire();\n  }\n\n  depart() {\n    if (this.episodeRunner) {\n      this.episodeRunner.depart();\n    }\n  }\n\n  episodeRunner?: EpisodeRunner;\n\n  goRel(siteStep: number) {\n    if (this.episodeRunner) {\n      this.episodeRunner.goRel(siteStep);\n    }\n  }\n\n  goTo(siteIndex: number) {\n    if (this.episodeRunner) {\n      this.episodeRunner.goTo(siteIndex);\n    }\n  }\n\n  async startEpisode(episode: Episode) {\n    this.episodeRunner = new EpisodeRunner(episode);\n    await this.episodeRunner.start();\n  }\n\n  wire() {\n    // TODO Put wiring in display?\n    let controls = document.querySelector('.control') as HTMLElement;\n    // Sites.\n    let arrows = [...controls.querySelectorAll('.arrows .arrow')];\n    arrows[0].addEventListener('click', () => this.goRel(-1));\n    arrows[1].addEventListener('click', () => this.goRel(1));\n    let goButtons = [...controls.querySelectorAll('.arrows .go')];\n    goButtons.forEach((button, index) => {\n      button.addEventListener('click', () => this.goTo(index));\n    });\n    // Other.\n    let depart = controls.querySelector('.depart .button') as HTMLElement;\n    depart.addEventListener('click', () => this.depart());\n  }\n\n}\n\nclass EpisodeRunner {\n\n  constructor(episode: Episode) {\n    this.episode = episode;\n  }\n\n  async depart() {\n    // TODO On last round, depart means to end or to capture/encounter?\n    if (this.roundIndex < this.episode.rounds.length - 1) {\n      this.roundIndex += 1;\n      await this.startRound();\n    }\n  }\n\n  episode: Episode;\n\n  async goRel(siteStep: number) {\n    let {length} = this.round.sites;\n    let siteIndex = (this.siteIndex + siteStep) % length;\n    if (siteIndex < 0) {\n      siteIndex += length;\n    }\n    await this.goTo(siteIndex);\n  }\n\n  async goTo(siteIndex: number) {\n    this.siteIndex = siteIndex;\n    renderArrows(siteIndex);\n    await renderSite(this.site.site as FullSite);\n  }\n\n  get round() {\n    return this.episode.rounds[this.roundIndex];\n  }\n\n  roundIndex = 0;\n\n  get site() {\n    return this.round.sites[this.siteIndex];\n  }\n\n  siteIndex = 0;\n\n  async start() {\n    let {episode} = this;\n    console.log(episode);\n    this.episode = episode;\n    this.roundIndex = 0;\n    await this.startRound();\n  }\n\n  async startRound() {\n    if (this.roundIndex == this.episode.rounds.length - 1) {\n      // TODO Put rendering in display.\n      let depart = document.querySelector('.depart') as HTMLElement;\n      depart.classList.add('disabled');\n    }\n    renderRound(this.roundIndex, this.episode);\n    await this.goTo(0);\n  }\n\n}\n","import {generateEpisode} from './episode';\nimport {Game} from './game';\nimport {MinPlace} from './place';\n\naddEventListener('load', main);\n\nasync function main() {\n  // TODO If served from github, grab the commit id and use the explicit rev.\n  // TODO Actually, that also requires the same js build, too, unless we\n  // TODO remember the full list of things.\n  let places =\n    await (await fetch('places/places-en.json')).json() as MinPlace[];\n  // console.log(places);\n  let game = new Game();\n  let episode = await generateEpisode(places);\n  await game.startEpisode(episode);\n}\n"]}