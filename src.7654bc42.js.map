{"version":3,"sources":["random.ts","util.ts","episode.ts","display.ts","game.ts","index.ts"],"names":[],"mappings":"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","file":"src.7654bc42.js","sourceRoot":"src","sourcesContent":["export class Random {\n\n\tconstructor(seed?: number) {\n    if (!seed) {\n      seed = crypto.getRandomValues(new Int32Array(1))[0] || 1;\n    }\n    this.state = seed;\n\t}\n\n\tnext() {\n\t\treturn this.state = xorshift32(this.state);\n\t}\n\n\tnextInt(min: number, max: number): number {\n\t\treturn Math.floor(map(this.next(), min, max + 1));\n\t}\n\n\tnextItem<Item>(items: Item[]): Item {\n\t\treturn items[this.nextInt(0, items.length - 1)];\n\t}\n\n\tshuffled<Item>(items: Item[]) {\n\t\tlet result = items.slice();\n\t\t// For non-full samples, Vitter's Method D might be good.\n\t\tfor (let i = result.length - 1; i > 0; i -= 1) {\n\t\t\tlet j = this.nextInt(0, i);\n\t\t\tlet temp = result[i];\n\t\t\tresult[i] = result[j];\n\t\t\tresult[j] = temp;\n\t\t}\n\t\treturn result;\n  }\n\n\tstate: number;\n\n}\n\nlet i32Min = -0x80000000;\nlet i32Max = 0x7FFFFFFF;\n\nfunction map(x: number, min: number, max: number) {\n\treturn (x - i32Min) / (i32Max - i32Min) * (max - min) + min;\n}\n\n// TODO Consider splitmix64 or others sometime.\nfunction xorshift32(x: number) {\n\t// See:\n\t// http://www.jstatsoft.org/v08/i14/paper\n\t// https://en.wikipedia.org/wiki/Xorshift\n  x ^= x << 13;\n  x ^= x >> 17;\n  x ^= x << 5;\n  return x;\n}\n","export async function fetchObjectUri(uri: string) {\n  return URL.createObjectURL(await (await fetch(uri)).blob());\n}\n","import {Random} from './random';\nimport {FullSite, MinPlace, MinSite} from './place';\nimport {fetchObjectUri} from './util';\n\nexport type int = number;\nexport type Clue = string;\n\nexport interface ClueSite {\n  clue: Clue;\n  site: MinSite;\n}\n\nexport interface Episode {\n  // TODO Perpetrator\n  rounds: Round[];\n  seed: string;\n}\n\nexport interface EpisodeOptions {\n  cluesPerPlace?: int;\n  roundsPerEpisode?: int;\n  seed?: int;\n}\n\nexport interface Round {\n  place: MinPlace;\n  sites: ClueSite[];\n}\n\nexport async function generateEpisode(\n  places: MinPlace[], options: EpisodeOptions = {},\n) {\n  let episode = new EpisodeGenerator(places, options).generate();\n  await Promise.all(episode.rounds.map(async round => {\n    let {place} = round;\n    // Update place sites, which are the same sites as for the round.\n    // TODO If we reach a point of more sites than use with shuffling, load the\n    // TODO round clue sites rather than all the place sites.\n    let imageRequests = Promise.all(place.sites.map(async site => {\n      // TODO Remember to URL.revokeObjectURL() after each round?\n      site.image = await fetchObjectUri(`places/${place.id}/${site.image}`);\n    }));\n    let text =\n      await (await fetch(`places/${place.id}/${place.id}.html`)).text();\n    let data = new DOMParser().parseFromString(text, \"text/html\");\n    [...data.querySelectorAll('#sites > *')].forEach((siteBox, siteIndex) => {\n      let site = place.sites[siteIndex] as FullSite;\n      // Names.\n      let heading = siteBox.querySelector('h2')!;\n      let divs = heading.children;\n      site.name = divs[0].textContent!;\n      // TODO Extract by game language. Or have files extracted for each lang?\n      site.nameUi = divs[1].textContent!;\n      // Credit.\n      let credit = siteBox.querySelector('.credit')!;\n      site.credit = credit.innerHTML;\n    })\n    await imageRequests;\n  }));\n  return episode;\n}\n\nclass EpisodeGenerator {\n\n  constructor(places: MinPlace[], options: EpisodeOptions = {}) {\n    let {seed} = options;\n    let random = new Random(seed);\n    Object.assign(\n      this,\n      // Defaults.\n      {\n        cluesPerPlace: 5,\n        roundsPerEpisode: 5 + 1,\n      },\n      // Options.\n      options,\n      // Explicits and overrides.\n      {\n        places,\n        random,\n        seed: random.state,\n      },\n    );\n  }\n\n  generate(): Episode {\n    // TODO Perp.\n    // The random selection order has to be constant here.\n    // Select places without replacement, for better variety.\n    let places =\n      this.random.shuffled(this.places).slice(0, this.roundsPerEpisode);\n    let rounds =\n      places.map((place, index) => this.nextRound(place, places[index + 1]));\n    // Prep buffer for episode id.\n    let data = new DataView(new ArrayBuffer(4));\n    // Set with little endianness, since that's most common these days.\n    // What matters is that we have it consistent and defined.\n    data.setInt32(0, this.seed);\n    // Convert to base64.\n    // This doesn't get us far on just a 32 bit id, but we'll have git commit\n    // ids and possibly more random seed size later.\n    let seed = btoa(String.fromCharCode(...new Uint8Array(data.buffer)));\n    console.log(seed);\n    // Done.\n    return {rounds, seed};\n  }\n\n  nextRound(place: MinPlace, nextPlace?: MinPlace): Round {\n    // Important! The order of generation can't be changed, or else it breaks\n    // deterministic generation!\n    let {cluesPerPlace, places, random, roundsPerEpisode} = this;\n    // Current place and next.\n    nextPlace = this.roundIndex < roundsPerEpisode ?\n      random.nextItem(places) :\n      undefined;\n    // Sites.\n    let sitesContext = {cluesPerPlace, nextPlace, place, random};\n    let sites = cluesPerPlace > place.sites.length ?\n      sampleReplacedSites(sitesContext) :\n      sampleShuffledSites(sitesContext);\n    // Update and done.\n    this.roundIndex += 1;\n    return {place, sites};\n  }\n\n  cluesPerPlace!: int;\n\n  places!: MinPlace[];\n\n  roundsPerEpisode!: int;\n\n  random!: Random;\n\n  roundIndex = 0;\n\n  seed!: int;\n\n}\n\n// Private.\n\ninterface ClueContext {\n  nextPlace?: MinPlace;\n  random: Random;\n  site: MinSite;\n}\n\ninterface SitesContext {\n  cluesPerPlace: number;\n  nextPlace?: MinPlace;\n  place: MinPlace;\n  random: Random;\n}\n\nfunction buildClueSite({nextPlace, random, site}: ClueContext) {\n  let clue = '';\n  // Generate numbers now even if not used yet, for consistent production.\n  // TODO Remove this once really getting clues.\n  // TODO Do we get any \"clues\" at the last place?\n  if (nextPlace) {\n    random.nextInt(0, nextPlace!.sites.length);\n  }\n  return { clue, site } as ClueSite;\n}\n\nfunction sampleReplacedSites(context: SitesContext) {\n  let {cluesPerPlace, nextPlace, place, random} = context;\n  return [...Array(cluesPerPlace).keys()].map(() => {\n    // TODO This samples with replacement. Probably just shuffle instead.\n    let site = random.nextItem(place.sites);\n    return buildClueSite({nextPlace, random, site});\n  });\n}\n\nfunction sampleShuffledSites(context: SitesContext) {\n  let {cluesPerPlace, nextPlace, place, random} = context;\n  // Keep the overview first.\n  let sites = [place.sites[0]];\n  // Then shuffle the rest.\n  sites.push(...random.shuffled(place.sites.slice(1)));\n  // But keep only a subset, in case we have more than required.\n  return sites.slice(0, cluesPerPlace).map(site => {\n    return buildClueSite({nextPlace, random, site});\n  });\n}\n","import {Episode} from './episode';\nimport {FullSite, MinPlace} from './place';\n\nexport function renderArrows(siteIndex: number) {\n  let controls = document.querySelector('.control') as HTMLElement;\n  let goButtons = [...controls.querySelectorAll('.arrows .go')];\n  goButtons.forEach((element, index) => {\n    let button = element as HTMLElement;\n    if (siteIndex == index) {\n      button.classList.add('active');\n    } else {\n      button.classList.remove('active');\n    }\n  })\n}\n\nexport function renderRound(roundIndex: number, episode: Episode) {\n  let box = document.querySelector('.round') as HTMLElement;\n  let roundNumber = roundIndex + 1;\n  let {length} = episode.rounds;\n  box.textContent = roundNumber < length ?\n    `Round ${roundNumber}/${length - 1}` :\n    `Finale`;\n}\n\nexport async function renderSite(site: FullSite) {\n  // Image.\n  let img = document.querySelector('.photo img') as HTMLImageElement;\n  await setImgSrc(img, site.image);\n  let creditText = document.querySelector('.creditText') as HTMLElement;\n  creditText.innerHTML = site.credit;\n  // Controls.\n  (document.querySelector('.control') as HTMLElement).style.display = 'flex';\n  // Heading.\n  let headingKids = document.querySelector('h1')!.children;\n  headingKids[0].textContent = site.name;\n  headingKids[1].textContent = site.name == site.nameUi ? '' : site.nameUi;\n  // Text.\n  document.querySelector('.clue')!.textContent = 'Clue for the next place.';\n}\n\nfunction setImgSrc(img: HTMLImageElement, src: string): Promise<void> {\n  img.src = src;\n  return new Promise((resolve, reject) => {\n    if (img.complete) {\n      resolve();\n    }\n    img.addEventListener('error', onError);\n    img.addEventListener('load', onLoad);\n    // Functions.\n    function detach() {\n      img.removeEventListener('error', onError);\n      img.removeEventListener('load', onLoad);\n    }\n    function onError(event: ErrorEvent) {\n      detach();\n      reject(new Error(event.message));\n    }\n    function onLoad() {\n      detach();\n      resolve();\n    }\n  });\n}\n","import {renderArrows, renderRound, renderSite} from './display';\nimport {Episode} from './episode';\nimport {FullSite} from './place';\n\nexport class Game {\n\n  constructor() {\n    this.wire();\n  }\n\n  depart() {\n    if (this.episodeRunner) {\n      this.hideCredit();\n      this.episodeRunner.depart();\n    }\n  }\n\n  episodeRunner?: EpisodeRunner;\n\n  goRel(siteStep: number) {\n    if (this.episodeRunner) {\n      this.episodeRunner.goRel(siteStep);\n    }\n  }\n\n  goTo(siteIndex: number) {\n    if (this.episodeRunner) {\n      this.episodeRunner.goTo(siteIndex);\n    }\n  }\n\n  hideCredit() {\n    let {classList} = document.querySelector('.credit') as HTMLElement;\n    classList.remove('expanded');\n  }\n\n  async startEpisode(episode: Episode) {\n    this.episodeRunner = new EpisodeRunner(episode);\n    await this.episodeRunner.start();\n  }\n\n  toggleCredit() {\n    let {classList} = document.querySelector('.credit') as HTMLElement;\n    if (classList.contains('expanded')) {\n      classList.remove('expanded');\n    } else {\n      classList.add('expanded');\n    }\n  }\n\n  wire() {\n    // TODO Put wiring in display?\n    // Meta things.\n    let credit = document.querySelector('.credit') as HTMLElement;\n    let creditButton = credit.querySelector('.button')!;\n    creditButton.addEventListener('click', () => this.toggleCredit());\n    // Game controls.\n    let controls = document.querySelector('.control') as HTMLElement;\n    // Sites.\n    let arrows = [...controls.querySelectorAll('.arrows .arrow')];\n    arrows[0].addEventListener('click', () => this.goRel(-1));\n    arrows[1].addEventListener('click', () => this.goRel(1));\n    let goButtons = [...controls.querySelectorAll('.arrows .go')];\n    goButtons.forEach((button, index) => {\n      button.addEventListener('click', () => this.goTo(index));\n    });\n    // Other.\n    let depart = controls.querySelector('.depart .button') as HTMLElement;\n    depart.addEventListener('click', () => this.depart());\n  }\n\n}\n\nclass EpisodeRunner {\n\n  constructor(episode: Episode) {\n    this.episode = episode;\n  }\n\n  async depart() {\n    // TODO On last round, depart means to end or to capture/encounter?\n    if (this.roundIndex < this.episode.rounds.length - 1) {\n      this.roundIndex += 1;\n      await this.startRound();\n    }\n  }\n\n  episode: Episode;\n\n  async goRel(siteStep: number) {\n    let {length} = this.round.sites;\n    let siteIndex = (this.siteIndex + siteStep) % length;\n    if (siteIndex < 0) {\n      siteIndex += length;\n    }\n    await this.goTo(siteIndex);\n  }\n\n  async goTo(siteIndex: number) {\n    this.siteIndex = siteIndex;\n    renderArrows(siteIndex);\n    await renderSite(this.site.site as FullSite);\n  }\n\n  get round() {\n    return this.episode.rounds[this.roundIndex];\n  }\n\n  roundIndex = 0;\n\n  get site() {\n    return this.round.sites[this.siteIndex];\n  }\n\n  siteIndex = 0;\n\n  async start() {\n    let {episode} = this;\n    console.log(episode);\n    this.episode = episode;\n    this.roundIndex = 0;\n    await this.startRound();\n  }\n\n  async startRound() {\n    if (this.roundIndex == this.episode.rounds.length - 1) {\n      // TODO Put rendering in display.\n      let depart = document.querySelector('.depart') as HTMLElement;\n      depart.classList.add('disabled');\n    }\n    renderRound(this.roundIndex, this.episode);\n    await this.goTo(0);\n  }\n\n}\n","import {generateEpisode} from './episode';\nimport {Game} from './game';\nimport {MinPlace} from './place';\n\naddEventListener('load', main);\n\nasync function main() {\n  // TODO If served from github, grab the commit id and use the explicit rev.\n  // TODO Actually, that also requires the same js build, too, unless we\n  // TODO remember the full list of things.\n  let places =\n    await (await fetch('places/places-en.json')).json() as MinPlace[];\n  // console.log(places);\n  let game = new Game();\n  let episode = await generateEpisode(places);\n  await game.startEpisode(episode);\n}\n"]}