{"version":3,"sources":["random.ts","episode.ts","ui.ts","index.ts"],"names":[],"mappings":";AAwCC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAxCD,MAAa,EAEZ,YAAY,GACJ,IACH,EAAO,OAAO,gBAAgB,IAAI,WAAW,IAAI,IAAM,GAEpD,KAAA,MAAQ,EAGhB,OACQ,OAAA,KAAK,MAAQ,EAAW,KAAK,OAGrC,QAAQ,EAAa,GACb,OAAA,KAAK,MAAM,EAAI,KAAK,OAAQ,EAAK,EAAM,IAG/C,SAAe,GACP,OAAA,EAAM,KAAK,QAAQ,EAAG,EAAM,OAAS,KAlB9C,QAAA,OAAA,EAyBA,IAAI,GAAU,WACV,EAAS,WAEb,SAAS,EAAI,EAAW,EAAa,GAC7B,OAAC,EAAI,IAAW,EAAS,IAAW,EAAM,GAAO,EAGzD,SAAS,EAAW,GAOX,OAHP,GAAK,GAAK,GACV,GAAK,GAAK,GACV,GAAK,GAAK;;ACdZ,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAxBA,MAAA,EAAA,QAAA,YAwBA,MAAa,EAEX,YAAY,EAAoB,EAA0B,IAiD1D,KAAA,eAAuB,EAQvB,KAAA,WAAa,EAxDP,IAAA,KAAC,GAAQ,EACT,EAAS,IAAI,EAAA,OAAO,GACxB,OAAO,OACL,KAEA,CACE,cAAe,EACf,iBAAkB,GAGpB,EAEA,CACE,OAAA,EACA,OAAA,EACA,KAAM,EAAO,QAKnB,YAGM,IASA,GATA,cAAC,EAAD,UAAgB,EAAhB,OAA2B,EAA3B,OAAmC,EAAnC,iBAA2C,GAAoB,KAE/D,EAAQ,GAAa,EAAO,SAAS,GAGrC,EAAQ,IAAI,MAAM,GAAe,QAAQ,IAC3C,IAAM,EAAO,SAAS,EAAM,QAcvB,OAVH,KAAK,WAAa,GACpB,EAAY,EAAO,SAAS,IAC5B,EAAQ,IAAI,MAAM,GAAe,QAAQ,IAAI,IAAM,KAE7C,QAAQ,IAAM,EAAO,QAAQ,EAAG,EAAW,MAAM,UAGvD,EAAQ,GAGH,CAAC,MAAA,EAAO,UAAA,EAAW,MAAA,EAAO,MAAA,IA9CrC,QAAA,iBAAA;;ACrBA,aAAA,SAAgB,EAAY,GACd,SAAS,cAAc,cAC7B,eAAiB,EAAM,MAAM,EAAM,MAAM,GAAG,QAFpD,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA;;ACeC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAlBD,MAAA,EAAA,QAAA,aAEA,EAAA,QAAA,QAIA,eAAe,IAIT,IAAA,cACW,MAAM,0BAA0B,OAG3C,EADY,IAAI,EAAA,iBAAiB,GACf,YACtB,QAAQ,IAAI,EAAM,OAClB,QAAQ,IAAI,EAAM,MAAM,IACxB,EAAA,YAAY,EAAM,OAbpB,iBAAiB,OAAQ","file":"src.4c7128c7.js","sourceRoot":"src","sourcesContent":["export class Random {\n\n\tconstructor(seed?: number) {\n    if (!seed) {\n      seed = crypto.getRandomValues(new Int32Array(1))[0] || 1;\n    }\n    this.state = seed;\n\t}\n\n\tnext() {\n\t\treturn this.state = xorshift32(this.state);\n\t}\n\n\tnextInt(min: number, max: number): number {\n\t\treturn Math.floor(map(this.next(), min, max + 1));\n\t}\n\n\tnextItem<Item>(array: Item[]): Item {\n\t\treturn array[this.nextInt(0, array.length - 1)];\n\t}\n\n\tstate: number;\n\n}\n\nlet i32Min = -0x80000000;\nlet i32Max = 0x7FFFFFFF;\n\nfunction map(x: number, min: number, max: number) {\n\treturn (x - i32Min) / (i32Max - i32Min) * (max - min) + min;\n}\n\nfunction xorshift32(x: number) {\n\t// See:\n\t// http://www.jstatsoft.org/v08/i14/paper\n\t// https://en.wikipedia.org/wiki/Xorshift\n  x ^= x << 13;\n  x ^= x >> 17;\n  x ^= x << 5;\n  return x;\n}\n","import {Random} from './random';\nimport {MinPlace, MinSite} from './place';\n\ntype int = number;\ntype Clue = string;\n\ninterface Episode {\n  // TODO Criminal\n  rounds: Round[];\n}\n\ninterface EpisodeOptions {\n  cluesPerPlace?: int;\n  roundsPerEpisode?: int;\n  seed?: int;\n}\n\nexport interface Round {\n  clues: Clue[];\n  nextPlace?: MinPlace;\n  place: MinPlace;\n  sites: MinSite[];\n}\n\nexport class EpisodeGenerator {\n\n  constructor(places: MinPlace[], options: EpisodeOptions = {}) {\n    let {seed} = options;\n    let random = new Random(seed);\n    Object.assign(\n      this,\n      // Defaults.\n      {\n        cluesPerPlace: 5,\n        roundsPerEpisode: 5,\n      },\n      // Options.\n      options,\n      // Explicits and overrides.\n      {\n        places,\n        random,\n        seed: random.state,\n      },\n    );\n  }\n\n  nextRound(): Round {\n    // Important! The order of generation can't be changed, or else it breaks\n    // deterministic generation!\n    let {cluesPerPlace, nextPlace, places, random, roundsPerEpisode} = this;\n    // Current place.\n    let place = nextPlace || random.nextItem(places);\n    // Sites.\n    // TODO Always include skyline with clue, or just without clue?\n    let sites = [...Array(cluesPerPlace).keys()].map(\n      () => random.nextItem(place.sites),\n    );\n    // Next place and clues.\n    let clues: Clue[];\n    if (this.roundIndex < roundsPerEpisode) {\n      nextPlace = random.nextItem(places);\n      clues = [...Array(cluesPerPlace).keys()].map(() => '');\n      // Generate numbers now even if not used yet, for consistent production.\n      clues.forEach(() => random.nextInt(0, nextPlace!.sites.length));\n    } else {\n      // Do we get any \"clues\" at the last place?\n      clues = [];\n    }\n    // Done.\n    return {clues, nextPlace, place, sites};\n  }\n\n  cluesPerPlace!: int;\n\n  nextPlace?: MinPlace = undefined;\n\n  places!: MinPlace[];\n\n  roundsPerEpisode!: int;\n\n  random!: Random;\n\n  roundIndex = 0;\n\n  seed!: int;\n\n}\n","// import {Round} from './episode';\nimport {MinPlace} from './place';\n\nexport function renderPlace(place: MinPlace) {\n  let image = document.querySelector('.photo img') as HTMLImageElement;\n  image.src = `/places/${place.id}/${place.sites[0].image}`;\n}\n","import {EpisodeGenerator} from './episode';\nimport {MinPlace} from './place';\nimport {renderPlace} from './ui';\n\naddEventListener('load', main);\n\nasync function main() {\n  // TODO If served from github, grab the commit id and use the explicit rev.\n  // TODO Actually, that also requires the same js build, too, unless we\n  // TODO remember the full list of things.\n  let places =\n    await (await fetch('places/places-en.json')).json() as MinPlace[];\n  // console.log(places);\n  let generator = new EpisodeGenerator(places);\n  let round = generator.nextRound();\n  console.log(round.place);\n  console.log(round.sites[0]);\n  renderPlace(round.place);\n}\n"]}