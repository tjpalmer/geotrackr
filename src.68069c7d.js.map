{"version":3,"sources":["random.ts","util.ts","episode.ts","display.ts","game.ts","index.ts"],"names":[],"mappings":"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","file":"src.68069c7d.js","sourceRoot":"src","sourcesContent":["export class Random {\n\n\tconstructor(seed?: number) {\n    if (!seed) {\n      seed = crypto.getRandomValues(new Int32Array(1))[0] || 1;\n    }\n    this.state = seed;\n\t}\n\n\tnext() {\n\t\treturn this.state = xorshift32(this.state);\n\t}\n\n\tnextInt(min: number, max: number): number {\n\t\treturn Math.floor(map(this.next(), min, max + 1));\n\t}\n\n\tnextItem<Item>(array: Item[]): Item {\n\t\treturn array[this.nextInt(0, array.length - 1)];\n\t}\n\n\tstate: number;\n\n}\n\nlet i32Min = -0x80000000;\nlet i32Max = 0x7FFFFFFF;\n\nfunction map(x: number, min: number, max: number) {\n\treturn (x - i32Min) / (i32Max - i32Min) * (max - min) + min;\n}\n\n// TODO Consider splitmix64 or others sometime.\nfunction xorshift32(x: number) {\n\t// See:\n\t// http://www.jstatsoft.org/v08/i14/paper\n\t// https://en.wikipedia.org/wiki/Xorshift\n  x ^= x << 13;\n  x ^= x >> 17;\n  x ^= x << 5;\n  return x;\n}\n","export async function fetchObjectUri(uri: string) {\n  return URL.createObjectURL(await (await fetch(uri)).blob());\n}\n","import {Random} from './random';\nimport {FullSite, MinPlace, MinSite} from './place';\nimport {fetchObjectUri} from './util';\n\nexport type int = number;\nexport type Clue = string;\n\nexport interface ClueSite {\n  clue: Clue;\n  site: MinSite;\n}\n\nexport interface Episode {\n  // TODO Perpetrator\n  rounds: Round[];\n  seed: string;\n}\n\nexport interface EpisodeOptions {\n  cluesPerPlace?: int;\n  roundsPerEpisode?: int;\n  seed?: int;\n}\n\nexport interface Round {\n  place: MinPlace;\n  sites: ClueSite[];\n}\n\nexport async function generateEpisode(\n  places: MinPlace[], options: EpisodeOptions = {},\n) {\n  let episode = new EpisodeGenerator(places, options).generate();\n  await Promise.all(episode.rounds.map(async round => {\n    let {place} = round;\n    // Update place sites, which are the same sites as for the round.\n    // TODO If we reach a point of more sites than use with shuffling, load the\n    // TODO round clue sites rather than all the place sites.\n    let imageRequests = Promise.all(place.sites.map(async site => {\n      // TODO Remember to URL.revokeObjectURL() after each round?\n      site.image = await fetchObjectUri(`places/${place.id}/${site.image}`);\n    }));\n    let text =\n      await (await fetch(`places/${place.id}/${place.id}.html`)).text();\n    let data = new DOMParser().parseFromString(text, \"text/html\");\n    [...data.querySelectorAll('#images h2')].forEach((heading, siteIndex) => {\n      let divs = heading.children;\n      (place.sites[siteIndex] as FullSite).name = divs[0].textContent!;\n      // TODO Extract by game language. Or have files extracted for each lang?\n      (place.sites[siteIndex] as FullSite).nameUi = divs[1].textContent!;\n    })\n    await imageRequests;\n  }));\n  return episode;\n}\n\nclass EpisodeGenerator {\n\n  constructor(places: MinPlace[], options: EpisodeOptions = {}) {\n    let {seed} = options;\n    let random = new Random(seed);\n    Object.assign(\n      this,\n      // Defaults.\n      {\n        cluesPerPlace: 5,\n        roundsPerEpisode: 5,\n      },\n      // Options.\n      options,\n      // Explicits and overrides.\n      {\n        places,\n        random,\n        seed: random.state,\n      },\n    );\n  }\n\n  generate(): Episode {\n    // TODO Perp.\n    // The order has to be constant here.\n    let rounds =\n      [...Array(this.roundsPerEpisode).keys()].map(() => this.nextRound());\n    // Prep buffer for episode id.\n    let data = new DataView(new ArrayBuffer(4));\n    // Set with little endianness, since that's most common these days.\n    // What matters is that we have it consistent and defined.\n    data.setInt32(0, this.seed);\n    // Convert to base64.\n    // This doesn't get us far on just a 32 bit id, but we'll have git commit\n    // ids and possibly more random seed size later.\n    let seed = btoa(String.fromCharCode(...new Uint8Array(data.buffer)));\n    console.log(seed);\n    // Done.\n    return {rounds, seed};\n  }\n\n  nextRound(): Round {\n    // Important! The order of generation can't be changed, or else it breaks\n    // deterministic generation!\n    let {cluesPerPlace, nextPlace, places, random, roundsPerEpisode} = this;\n    // Current place and next.\n    let place = nextPlace || random.nextItem(places);\n    nextPlace = this.roundIndex < roundsPerEpisode ?\n      random.nextItem(places) :\n      undefined;\n    // Sites.\n    // TODO Always include skyline with clue, or just without clue?\n    let sites = [...Array(cluesPerPlace).keys()].map(() => {\n      // TODO This samples with replacement. Probably just shuffle instead.\n      let site = random.nextItem(place.sites);\n      let clue = '';\n      // Generate numbers now even if not used yet, for consistent production.\n      // TODO Remove this once really getting clues.\n      // TODO Do we get any \"clues\" at the last place?\n      if (nextPlace) {\n        random.nextInt(0, nextPlace!.sites.length);\n      }\n      return {clue, site} as ClueSite;\n    });\n    // Update and done.\n    this.nextPlace = nextPlace;\n    this.roundIndex += 1;\n    return {place, sites};\n  }\n\n  cluesPerPlace!: int;\n\n  nextPlace?: MinPlace = undefined;\n\n  places!: MinPlace[];\n\n  roundsPerEpisode!: int;\n\n  random!: Random;\n\n  roundIndex = 0;\n\n  seed!: int;\n\n}\n","// import {Round} from './episode';\nimport {FullSite, MinPlace} from './place';\n\nexport async function renderPlace(place: MinPlace) {\n  // TODO Make sure we receive full places above, so to avoid casting.\n  let site = place.sites[0] as FullSite;\n  // Image.\n  let img = document.querySelector('.photo img') as HTMLImageElement;\n  await setImgSrc(img, site.image);\n  // Controls.\n  (document.querySelector('.control') as HTMLElement).style.display = 'flex';\n  // Heading.\n  let headingKids = document.querySelector('h1')!.children;\n  headingKids[0].textContent = site.name;\n  headingKids[1].textContent = site.nameUi;\n}\n\nfunction setImgSrc(img: HTMLImageElement, src: string): Promise<void> {\n  img.src = src;\n  return new Promise((resolve, reject) => {\n    if (img.complete) {\n      resolve();\n    }\n    img.addEventListener('error', onError);\n    img.addEventListener('load', onLoad);\n    // Functions.\n    function detach() {\n      img.removeEventListener('error', onError);\n      img.removeEventListener('load', onLoad);\n    }\n    function onError(event: ErrorEvent) {\n      detach();\n      reject(new Error(event.message));\n    }\n    function onLoad() {\n      detach();\n      resolve();\n    }\n  });\n}\n","import {renderPlace} from './display';\nimport {Episode} from './episode';\n\nexport class Game {\n\n  constructor() {\n    this.wire();\n  }\n\n  // TODO Extract an episode runner with an episode always set.\n  episode?: Episode;\n\n  roundIndex = 0;\n\n  async startEpisode(episode: Episode) {\n    console.log(episode);\n    this.episode = episode;\n    this.roundIndex = 0;\n    await this.startRound();\n  }\n\n  async startRound() {\n    let round = this.episode!.rounds[0];\n    await renderPlace(round.place);\n  }\n\n  wire() {\n    let controls = document.querySelector('.control') as HTMLElement;\n    let arrows = [...controls.querySelector('.arrows')!.children];\n    // TODO Call functions on the episode runner.\n    arrows[0].addEventListener('click', () => console.log('prev'));\n    arrows.slice(-1)[0].addEventListener('click', () => console.log('next'));\n    arrows.slice(1, -1).forEach((button, index) => {\n      button.addEventListener('click', () => console.log(`go to ${index}`));\n    })\n  }\n\n}\n","import {renderPlace} from './display';\nimport {generateEpisode} from './episode';\nimport {Game} from './game';\nimport {MinPlace} from './place';\n\naddEventListener('load', main);\n\nasync function main() {\n  // TODO If served from github, grab the commit id and use the explicit rev.\n  // TODO Actually, that also requires the same js build, too, unless we\n  // TODO remember the full list of things.\n  let places =\n    await (await fetch('places/places-en.json')).json() as MinPlace[];\n  // console.log(places);\n  let game = new Game();\n  let episode = await generateEpisode(places);\n  await game.startEpisode(episode);\n}\n"]}