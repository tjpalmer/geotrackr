{"version":3,"sources":["display.ts","random.ts","util.ts","episode.ts","geo.ts","game.ts","index.ts"],"names":[],"mappings":"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","file":"src.11e9ffc9.js","sourceRoot":"src","sourcesContent":["import {ClueSite, Episode} from './episode';\nimport {FullSite, Point2, SimpleSite} from './place';\n\nexport function renderArrows(siteIndex: number) {\n  let controls = document.querySelector('.control') as HTMLElement;\n  let goButtons = [...controls.querySelectorAll('.arrows .go')];\n  goButtons.forEach((element, index) => {\n    let button = element as HTMLElement;\n    if (siteIndex == index) {\n      button.classList.add('active');\n    } else {\n      button.classList.remove('active');\n    }\n  })\n}\n\nexport function renderPoint(point?: Point2) {\n  let pointBox = document.querySelector('.point') as HTMLElement;\n  if (point) {\n    pointBox.style.display = 'block';\n    pointBox.style.left = `${point[0] * 100}%`;\n    pointBox.style.top = `${point[1] * 100}%`;\n  } else {\n    pointBox.style.display = 'none';\n  }\n}\n\nexport function renderRound(roundIndex: number, episode: Episode) {\n  let box = document.querySelector('.round') as HTMLElement;\n  let roundNumber = roundIndex + 1;\n  let {length} = episode.rounds;\n  box.textContent = roundNumber < length ?\n    `Round ${roundNumber}/${length - 1}` :\n    `Finale`;\n}\n\nexport async function renderSite(clueSite: ClueSite) {\n  let site = clueSite.site as FullSite;\n  // Image.\n  await renderSiteImage(site);\n  // Controls.\n  (document.querySelector('.control') as HTMLElement).style.display = 'flex';\n  // Heading.\n  let headingKids = document.querySelector('h1')!.children;\n  headingKids[0].textContent = site.name;\n  headingKids[1].textContent = site.name == site.nameUi ? '' : site.nameUi;\n  // Text.\n  document.querySelector('.clue')!.innerHTML =\n    typeof clueSite.clue == 'string' ?\n      `The next place is ${clueSite.clue}.` :\n      '';\n}\n\nexport async function renderSiteImage(site: SimpleSite) {\n  let img = document.querySelector('.photo img') as HTMLImageElement;\n  await setImgSrc(img, site.image);\n  let creditText = document.querySelector('.creditText') as HTMLElement;\n  creditText.innerHTML = site.credit;\n}\n\nfunction setImgSrc(img: HTMLImageElement, src: string): Promise<void> {\n  img.src = src;\n  return new Promise((resolve, reject) => {\n    if (img.complete) {\n      resolve();\n    }\n    img.addEventListener('error', onError);\n    img.addEventListener('load', onLoad);\n    // Functions.\n    function detach() {\n      img.removeEventListener('error', onError);\n      img.removeEventListener('load', onLoad);\n    }\n    function onError(event: ErrorEvent) {\n      detach();\n      reject(new Error(event.message));\n    }\n    function onLoad() {\n      detach();\n      resolve();\n    }\n  });\n}\n","export class Random {\n\n\tconstructor(seed?: number) {\n    if (!seed) {\n      seed = crypto.getRandomValues(new Int32Array(1))[0] || 1;\n    }\n    this.state = seed;\n\t}\n\n\tnext() {\n\t\treturn this.state = xorshift32(this.state);\n\t}\n\n\tnextInt(min: number, max: number): number {\n\t\treturn Math.floor(map(this.next(), min, max + 1));\n\t}\n\n\tnextItem<Item>(items: Item[]): Item {\n\t\treturn items[this.nextInt(0, items.length - 1)];\n\t}\n\n\tshuffled<Item>(items: Item[]) {\n\t\tlet result = items.slice();\n\t\t// For non-full samples, Vitter's Method D might be good.\n\t\tfor (let i = result.length - 1; i > 0; i -= 1) {\n\t\t\tlet j = this.nextInt(0, i);\n\t\t\tlet temp = result[i];\n\t\t\tresult[i] = result[j];\n\t\t\tresult[j] = temp;\n\t\t}\n\t\treturn result;\n  }\n\n\tstate: number;\n\n}\n\nlet i32Min = -0x80000000;\nlet i32Max = 0x7FFFFFFF;\n\nfunction map(x: number, min: number, max: number) {\n\treturn (x - i32Min) / (i32Max - i32Min) * (max - min) + min;\n}\n\n// TODO Consider splitmix64 or others sometime.\nfunction xorshift32(x: number) {\n\t// See:\n\t// http://www.jstatsoft.org/v08/i14/paper\n\t// https://en.wikipedia.org/wiki/Xorshift\n  x ^= x << 13;\n  x ^= x >> 17;\n  x ^= x << 5;\n  return x;\n}\n","export async function fetchObjectUri(uri: string) {\n  return URL.createObjectURL(await (await fetch(uri)).blob());\n}\n","import {Random} from './random';\nimport {FullSite, MinPlace, MinSite, SimpleSite} from './place';\nimport {fetchObjectUri} from './util';\n\nexport type int = number;\nexport type Clue = string;\n\nexport interface ClueSite {\n  clue?: int | string;\n  site: MinSite;\n}\n\nexport interface Episode {\n  // TODO Perpetrator\n  rounds: Round[];\n  seed: string;\n  world: SimpleSite;\n}\n\nexport interface EpisodeOptions {\n  cluesPerPlace?: int;\n  roundsPerEpisode?: int;\n  seed?: int;\n}\n\nexport interface Round {\n  place: MinPlace;\n  sites: ClueSite[];\n}\n\nexport async function generateEpisode(\n  places: MinPlace[], options: EpisodeOptions = {},\n) {\n  // Generate the episode choices in advance.\n  let episode = new EpisodeGenerator(places, options).generate();\n  let {rounds} = episode;\n  // Load site data.\n  await Promise.all(rounds.map(async round => {\n    let {place} = round;\n    // Update place sites.\n    // Start image requests for just those needed for the round.\n    let imageRequests = Promise.all(round.sites.map(async clueSite => {\n      let {site} = clueSite;\n      // TODO Remember to URL.revokeObjectURL() after each round?\n      site.image = await fetchObjectUri(`places/${place.id}/${site.image}`);\n    }));\n    let worldCredit = (async () =>\n      await (await fetch(episode.world.credit)).text()\n    )();\n    let worldImage = fetchObjectUri(episode.world.image);\n    // Load the text data.\n    let text =\n      await (await fetch(`places/${place.id}/${place.id}.html`)).text();\n    let data = new DOMParser().parseFromString(text, \"text/html\");\n    // Clues.\n    place.clues = [...data.querySelectorAll('#clues > *')].map(\n      clueBox => clueBox.innerHTML,\n    );\n    // Sites, and easier just to get them all, since they come bundled.\n    [...data.querySelectorAll('#sites > *')].forEach((siteBox, siteIndex) => {\n      let site = place.sites[siteIndex] as FullSite;\n      // Names.\n      let heading = siteBox.querySelector('h2')!;\n      let divs = heading.children;\n      site.name = divs[0].textContent!;\n      // TODO Extract by game language. Or have files extracted for each lang?\n      site.nameUi = divs[1].textContent!;\n      // Credit.\n      let credit = siteBox.querySelector('.credit')!;\n      site.credit = credit.innerHTML;\n    })\n    // Now let the images finish.\n    Object.assign(episode.world, {\n      credit: await worldCredit, image: await worldImage,\n    });\n    await imageRequests;\n  }));\n  // Fill in the clues.\n  rounds.slice(0, -1).forEach((round, roundIndex) => {\n    // We just put in the strings above.\n    let clues = rounds[roundIndex + 1].place.clues as string[];\n    round.sites.forEach(site => {\n      // And all but the last round has clue indices for where's next.\n      site.clue = clues[site.clue as number];\n    });\n  });\n  // Done.\n  return episode;\n}\n\nclass EpisodeGenerator {\n\n  constructor(places: MinPlace[], options: EpisodeOptions = {}) {\n    let {seed} = options;\n    let random = new Random(seed);\n    Object.assign(\n      this,\n      // Defaults.\n      {\n        cluesPerPlace: 5,\n        roundsPerEpisode: 5 + 1,\n      },\n      // Options.\n      options,\n      // Explicits and overrides.\n      {\n        places,\n        random,\n        seed: random.state,\n      },\n    );\n  }\n\n  generate(): Episode {\n    // TODO Perp.\n    // The random selection order has to be constant here.\n    // Select places without replacement, for better variety.\n    let places =\n      this.random.shuffled(this.places).slice(0, this.roundsPerEpisode);\n    let rounds =\n      places.map((place, index) => this.nextRound(place, places[index + 1]));\n    // Prep buffer for episode id.\n    let data = new DataView(new ArrayBuffer(4));\n    // Set with little endianness, since that's most common these days.\n    // What matters is that we have it consistent and defined.\n    data.setInt32(0, this.seed);\n    // Convert to base64.\n    // This doesn't get us far on just a 32 bit id, but we'll have git commit\n    // ids and possibly more random seed size later.\n    let seed = btoa(String.fromCharCode(...new Uint8Array(data.buffer)));\n    console.log(seed);\n    // Done.\n    return {rounds, seed, world: {\n      credit: 'places/world/world.txt', image: 'places/world/world.webp',\n    }};\n  }\n\n  nextRound(place: MinPlace, nextPlace?: MinPlace): Round {\n    // Important! The order of generation can't be changed, or else it breaks\n    // deterministic generation!\n    let {cluesPerPlace, places, random, roundsPerEpisode} = this;\n    // Current place and next.\n    nextPlace = this.roundIndex < roundsPerEpisode ?\n      random.nextItem(places) :\n      undefined;\n    // Sites.\n    let sitesContext = {cluesPerPlace, nextPlace, place, random};\n    let sites = cluesPerPlace > place.sites.length ?\n      sampleReplacedSites(sitesContext) :\n      sampleShuffledSites(sitesContext);\n    // Update and done.\n    this.roundIndex += 1;\n    return {place, sites};\n  }\n\n  cluesPerPlace!: int;\n\n  places!: MinPlace[];\n\n  roundsPerEpisode!: int;\n\n  random!: Random;\n\n  roundIndex = 0;\n\n  seed!: int;\n\n}\n\n// Private.\n\ninterface ClueContext {\n  clue?: number;\n  nextPlace?: MinPlace;\n  random: Random;\n  site: MinSite;\n}\n\ninterface SitesContext {\n  cluesPerPlace: number;\n  nextPlace?: MinPlace;\n  place: MinPlace;\n  random: Random;\n}\n\nfunction buildClueSite({clue, nextPlace, random, site}: ClueContext) {\n  return {clue, site} as ClueSite;\n}\n\nfunction permutation(random: Random, count: int) {\n  return random.shuffled([...Array<int>(count).keys()]);\n}\n\nfunction sampleClues(context: SitesContext) {\n  let {cluesPerPlace, nextPlace, random} = context;\n  return nextPlace ?\n    permutation(random, nextPlace.clues.length).slice(0, cluesPerPlace) :\n    [];\n}\n\nfunction sampleReplacedSites(context: SitesContext) {\n  let {cluesPerPlace, nextPlace, place, random} = context;\n  let clues = sampleClues(context);\n  return [...Array(cluesPerPlace).keys()].map((_, index) => {\n    // TODO This samples with replacement. Probably just shuffle instead.\n    let site = random.nextItem(place.sites);\n    return buildClueSite({clue: clues[index], nextPlace, random, site});\n  });\n}\n\nfunction sampleShuffledSites(context: SitesContext) {\n  let {cluesPerPlace, nextPlace, place, random} = context;\n  let clues = sampleClues(context);\n  // Keep the overview first.\n  let sites = [place.sites[0]];\n  // Then shuffle the rest.\n  sites.push(...random.shuffled(place.sites.slice(1)));\n  // But keep only a subset, in case we have more than required.\n  return sites.slice(0, cluesPerPlace).map((site, index) => {\n    return buildClueSite({clue: clues[index], nextPlace, random, site});\n  });\n}\n","// Extracted from chrisveness/geodesy\n\n// The MIT License (MIT)\n//\n// Copyright (c) 2014 Chris Veness\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nexport function inverse(p1: LatLon, p2: LatLon) {\n  const φ1 = toRadians(p1[0]), λ1 = toRadians(p1[1]);\n  const φ2 = toRadians(p2[0]), λ2 = toRadians(p2[1]);\n\n  // allow alternative ellipsoid to be specified\n  const ellipsoid = ellipsoids.WGS84;\n  const { a, b, f } = ellipsoid;\n\n  const L = λ2 - λ1;\n  const tanU1 = (1-f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1 * cosU1;\n  const tanU2 = (1-f) * Math.tan(φ2), cosU2 = 1 / Math.sqrt((1 + tanU2*tanU2)), sinU2 = tanU2 * cosU2;\n\n  let sinλ: number, cosλ: number, sinσ = 0, cosσ = 0;\n  let cosSqα = 0, cos2σM = 0, σ = 0;\n\n  let λ = L, λʹ, iterations = 0;\n  const antimeridian = Math.abs(L) > π;\n  do {\n      sinλ = Math.sin(λ);\n      cosλ = Math.cos(λ);\n      let sinSqσ = (cosU2*sinλ) * (cosU2*sinλ) + (cosU1*sinU2-sinU1*cosU2*cosλ) * (cosU1*sinU2-sinU1*cosU2*cosλ);\n      if (Math.abs(sinSqσ) < Number.EPSILON) {\n        break;  // co-incident points\n      }\n      sinσ = Math.sqrt(sinSqσ);\n      cosσ = sinU1*sinU2 + cosU1*cosU2*cosλ;\n      σ = Math.atan2(sinσ, cosσ);\n      let sinα = cosU1 * cosU2 * sinλ / sinσ;\n      cosSqα = 1 - sinα*sinα;\n      cos2σM = (cosSqα != 0) ? (cosσ - 2*sinU1*sinU2/cosSqα) : 0; // on equatorial line cos²α = 0 (§6)\n      let C = f/16*cosSqα*(4+f*(4-3*cosSqα));\n      λʹ = λ;\n      λ = L + (1-C) * f * sinα * (σ + C*sinσ*(cos2σM+C*cosσ*(-1+2*cos2σM*cos2σM)));\n      const iterationCheck = antimeridian ? Math.abs(λ)-π : Math.abs(λ);\n      if (iterationCheck > π) throw new EvalError('λ > π');\n  } while (Math.abs(λ-λʹ) > 1e-12 && ++iterations<1000);\n  if (iterations >= 1000) throw new EvalError('Vincenty formula failed to converge');\n\n  const uSq = cosSqα * (a*a - b*b) / (b*b);\n  const A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));\n  const B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));\n  const Δσ = B*sinσ*(cos2σM+B/4*(cosσ*(-1+2*cos2σM*cos2σM)-\n      B/6*cos2σM*(-3+4*sinσ*sinσ)*(-3+4*cos2σM*cos2σM)));\n\n  const s = b*A*(σ-Δσ);\n\n  const α1 = Math.atan2(cosU2*sinλ,  cosU1*sinU2-sinU1*cosU2*cosλ);\n  const α2 = Math.atan2(cosU1*sinλ, -sinU1*cosU2+cosU1*sinU2*cosλ);\n\n  return {\n      distance:       s,\n      initialBearing: Math.abs(s) < Number.EPSILON ? NaN : wrap360(toDegrees(α1)),\n      finalBearing:   Math.abs(s) < Number.EPSILON ? NaN : wrap360(toDegrees(α2)),\n      iterations:     iterations,\n  };\n}\n\ntype LatLon = [number, number];\n\nconst ellipsoids = {\n  WGS84: { a: 6378137, b: 6356752.314245, f: 1/298.257223563 },\n};\n\nconst π = Math.PI;\n\nfunction toDegrees(x: number) {\n  return x * 180 / Math.PI;\n}\n\nfunction toRadians(x: number) {\n  return x * Math.PI / 180;\n}\n\nfunction wrap360(degrees: number) {\n  if (0<=degrees && degrees<360) return degrees; // avoid rounding due to arithmetic ops if within range\n  return (degrees%360+360) % 360; // sawtooth wave p:360, a:360\n}\n","import {renderArrows, renderSiteImage, renderRound, renderSite, renderPoint} from './display';\nimport {Episode, generateEpisode} from './episode';\nimport {inverse} from './geo';\nimport {MinPlace, Point2} from './place';\n\nexport interface GameData {\n  places: MinPlace[];\n}\n\nexport class Game {\n\n  constructor(data: GameData) {\n    Object.assign(this, data);\n    this.wire();\n  }\n\n  depart() {\n    if (this.episodeRunner) {\n      this.hideCredit();\n      this.episodeRunner.depart();\n    }\n  }\n\n  episodeRunner?: EpisodeRunner;\n\n  goRel(siteStep: number) {\n    if (this.episodeRunner) {\n      this.episodeRunner.goRel(siteStep);\n    }\n  }\n\n  goTo(siteIndex: number) {\n    if (this.episodeRunner) {\n      this.episodeRunner.goTo(siteIndex);\n    }\n  }\n\n  hideCredit() {\n    let {classList} = document.querySelector('.credit') as HTMLElement;\n    classList.remove('expanded');\n  }\n\n  places!: MinPlace[];\n\n  pointAt(event: MouseEvent) {\n    event.preventDefault();\n    let credit = document.querySelector('.credit') as HTMLElement;\n    if (event.buttons & 1) {\n      credit.style.pointerEvents = 'none';\n      let bounds = (event.target as HTMLElement).getBoundingClientRect();\n      let x = (event.x - bounds.left) / bounds.width;\n      let y = (event.y - bounds.top) / bounds.height;\n      if (this.episodeRunner) {\n        this.episodeRunner.pointAt([x, y]);\n      }\n    } else {\n      credit.style.pointerEvents = 'auto';\n    }\n  }\n\n  async run() {\n    let episode = await generateEpisode(this.places);\n    await this.startEpisode(episode);\n  }\n\n  async startEpisode(episode: Episode) {\n    this.episodeRunner = new EpisodeRunner({episode, game: this});\n    await this.episodeRunner.start();\n  }\n\n  toggleCredit() {\n    let {classList} = document.querySelector('.credit') as HTMLElement;\n    if (classList.contains('expanded')) {\n      classList.remove('expanded');\n    } else {\n      classList.add('expanded');\n    }\n  }\n\n  wire() {\n    // TODO Put wiring in display?\n    // Meta things.\n    let credit = document.querySelector('.credit') as HTMLElement;\n    let creditButton = credit.querySelector('.button')!;\n    creditButton.addEventListener('click', () => this.toggleCredit());\n    // Map click handling.\n    let photo = document.querySelector('.photo img') as HTMLElement;\n    photo.addEventListener('mousedown', event => this.pointAt(event));\n    photo.addEventListener('mousemove', event => this.pointAt(event));\n    photo.addEventListener('mouseup', event => this.pointAt(event));\n    // Game controls.\n    let controls = document.querySelector('.control') as HTMLElement;\n    // Sites.\n    let arrows = [...controls.querySelectorAll('.arrows .arrow')];\n    arrows[0].addEventListener('click', () => this.goRel(-1));\n    arrows[1].addEventListener('click', () => this.goRel(1));\n    let goButtons = [...controls.querySelectorAll('.arrows .go')];\n    goButtons.forEach((button, index) => {\n      button.addEventListener('click', () => this.goTo(index));\n    });\n    // Other.\n    let depart = controls.querySelector('.depart .button') as HTMLElement;\n    depart.addEventListener('click', () => this.depart());\n  }\n\n}\n\ninterface EpisodeRunnerData {\n  episode: Episode;\n  game: Game;\n}\n\nclass EpisodeRunner {\n\n  constructor(data: EpisodeRunnerData) {\n    Object.assign(this, data);\n  }\n\n  cancelDepart() {\n    if (this.departing) {\n      this.departing = false;\n      document.querySelector('.depart .button')!.textContent = 'Depart';\n      renderPoint();\n    }\n  }\n\n  async chooseDestination() {\n    await renderSiteImage(this.episode.world);\n  }\n\n  async depart() {\n    // TODO On last round, depart means to end or to capture/encounter?\n    if (this.roundIndex < this.episode.rounds.length - 1) {\n      if (this.departing) {\n        this.roundIndex += 1;\n        await this.startRound();\n      } else {\n        this.departing = true;\n        renderPoint(this.point);\n        document.querySelector('.depart .button')!.textContent = 'Confirm';\n        await this.chooseDestination();\n      }\n    }\n  }\n\n  departing = false;\n\n  episode!: Episode;\n\n  game!: Game;\n\n  async goRel(siteStep: number) {\n    let {length} = this.round.sites;\n    let siteIndex = (this.siteIndex + siteStep) % length;\n    if (siteIndex < 0) {\n      siteIndex += length;\n    }\n    await this.goTo(siteIndex);\n  }\n\n  async goTo(siteIndex: number) {\n    this.cancelDepart();\n    this.siteIndex = siteIndex;\n    renderArrows(siteIndex);\n    await renderSite(this.site);\n  }\n\n  point?: Point2;\n\n  pointAt(point: Point2) {\n    if (!this.departing) {\n      return;\n    }\n    this.point = point;\n    renderPoint(point);\n    if (true) {\n      let latLon = [(0.5 - point[1]) * 180, (point[0] - 0.5) * 360] as Point2;\n      let {point: trueLatLon} = this.episode.rounds[this.roundIndex + 1].place;\n      let distance = inverse(latLon, trueLatLon).distance;\n      console.log(latLon, distance);\n    }\n  }\n\n  get round() {\n    return this.episode.rounds[this.roundIndex];\n  }\n\n  roundIndex = 0;\n\n  get site() {\n    return this.round.sites[this.siteIndex];\n  }\n\n  siteIndex = 0;\n\n  async start() {\n    let {episode} = this;\n    console.log(episode);\n    this.episode = episode;\n    this.roundIndex = 0;\n    await this.startRound();\n  }\n\n  async startRound() {\n    this.point = undefined;\n    if (this.roundIndex == this.episode.rounds.length - 1) {\n      // TODO Put rendering in display.\n      let depart = document.querySelector('.depart') as HTMLElement;\n      depart.classList.add('disabled');\n    }\n    renderRound(this.roundIndex, this.episode);\n    await this.goTo(0);\n  }\n\n}\n","import {generateEpisode} from './episode';\nimport {Game} from './game';\nimport {MinPlace} from './place';\nimport {fetchObjectUri} from './util';\n\naddEventListener('load', main);\n\nasync function main() {\n  // TODO If served from github, grab the commit id and use the explicit rev.\n  // TODO Actually, that also requires the same js build, too, unless we\n  // TODO remember the full list of things.\n  let places = (async () =>\n    await (await fetch('places/places-en.json')).json() as MinPlace[]\n  )();\n  // console.log(places);\n  let game = new Game({places: await places});\n  await game.run();\n}\n"]}